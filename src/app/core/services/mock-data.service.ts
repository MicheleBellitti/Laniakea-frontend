import { Injectable } from '@angular/core';
import { PhysicsMetadata, ModelSummary, ModelDetail, PredictionResult } from '../models';

@Injectable({ providedIn: 'root' })
export class MockDataService {

  // ============================================
  // PHYSICS PROBLEMS
  // ============================================
  getProblems(): PhysicsMetadata[] {
    return [
      {
        id: 'lane-emden',
        name: 'Lane-Emden Equation',
        description: 'Models the internal structure of self-gravitating polytropic spheres, fundamental for understanding stellar interiors, white dwarfs, and neutron stars.',
        category: 'stellar',
        governingEquation: '\\frac{1}{\\xi^2}\\frac{d}{d\\xi}\\left(\\xi^2\\frac{d\\theta}{d\\xi}\\right) + \\theta^n = 0',
        boundaryConditions: ['θ(0) = 1', "θ'(0) = 0"],
        parameters: [
          { name: 'Polytropic Index', symbol: 'n', description: 'Determines the equation of state relating pressure to density', min: 0, max: 5, default: 1.5, step: 0.1 }
        ],
        outputVariables: [
          { name: 'Density', symbol: 'θ', description: 'Dimensionless density profile' }
        ],
        physicsContext: 'The Lane-Emden equation describes hydrostatic equilibrium in stars.'
      },
      {
        id: 'poisson-gravity',
        name: 'Poisson Equation',
        description: 'Describes gravitational potential fields generated by mass distributions, essential for galactic dynamics and dark matter modeling.',
        category: 'gravity',
        governingEquation: '\\nabla^2 \\Phi = 4\\pi G \\rho',
        boundaryConditions: ['Φ → 0 as r → ∞'],
        parameters: [
          { name: 'Central Density', symbol: 'ρ₀', description: 'Peak density of the mass distribution', min: 0.1, max: 10, default: 1, step: 0.1 },
          { name: 'Scale Length', symbol: 'a', description: 'Characteristic size of the distribution', min: 0.1, max: 5, default: 1, step: 0.1 }
        ],
        outputVariables: [
          { name: 'Potential', symbol: 'Φ', description: 'Gravitational potential' }
        ],
        physicsContext: 'Fundamental equation for Newtonian gravity.'
      },
      {
        id: 'schrodinger-1d',
        name: 'Schrödinger Equation (1D)',
        description: 'Quantum mechanical wave equation for particle behavior in potential wells, foundational for quantum physics and chemistry.',
        category: 'quantum',
        governingEquation: '-\\frac{\\hbar^2}{2m}\\frac{d^2\\psi}{dx^2} + V(x)\\psi = E\\psi',
        boundaryConditions: ['ψ → 0 as x → ±∞'],
        parameters: [
          { name: 'Energy Level', symbol: 'E', description: 'Quantum energy eigenvalue', min: 0.1, max: 10, default: 1, step: 0.1 },
          { name: 'Potential Depth', symbol: 'V₀', description: 'Depth of the potential well', min: 1, max: 20, default: 5, step: 0.5 }
        ],
        outputVariables: [
          { name: 'Wave Function', symbol: 'ψ', description: 'Probability amplitude' }
        ],
        physicsContext: 'Describes quantum behavior of particles.'
      },
      {
        id: 'heat-diffusion',
        name: 'Heat Diffusion Equation',
        description: 'Models thermal conduction and heat transfer in materials, with applications from planetary cooling to stellar evolution.',
        category: 'thermodynamics',
        governingEquation: '\\frac{\\partial T}{\\partial t} = \\alpha \\nabla^2 T',
        boundaryConditions: ['T(0,t) = T₀', 'T(L,t) = T₁'],
        parameters: [
          { name: 'Thermal Diffusivity', symbol: 'α', description: 'Rate of heat diffusion through the material', min: 0.01, max: 1, default: 0.1, step: 0.01 },
          { name: 'Initial Temperature', symbol: 'T₀', description: 'Starting temperature distribution', min: 0, max: 100, default: 50, step: 1 }
        ],
        outputVariables: [
          { name: 'Temperature', symbol: 'T', description: 'Temperature field' }
        ],
        physicsContext: 'Fundamental for thermal physics and engineering.'
      }
    ];
  }

  // ============================================
  // MODELS
  // ============================================
  getModels(problemType?: string): ModelSummary[] {
    const allModels: ModelSummary[] = [
      // Lane-Emden Models
      {
        id: 'lane-emden-baseline',
        name: 'Lane-Emden Standard PINN',
        problemType: 'lane-emden',
        description: 'Baseline physics-informed neural network trained on the Lane-Emden equation with polytropic indices n ∈ [0, 5].',
        isBaseline: true,
        trainedAt: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString(),
        metrics: { totalLoss: 2.3e-6, physicsLoss: 1.8e-6, dataLoss: 5e-7, epochs: 50000, trainingTime: 1200 }
      },
      {
        id: 'lane-emden-deep',
        name: 'Lane-Emden Deep Network',
        problemType: 'lane-emden',
        description: 'Deeper architecture with 6 hidden layers for improved accuracy on challenging polytropic indices.',
        isBaseline: false,
        trainedAt: new Date(Date.now() - 3 * 24 * 60 * 60 * 1000).toISOString(),
        metrics: { totalLoss: 8.7e-7, physicsLoss: 6.2e-7, dataLoss: 2.5e-7, epochs: 80000, trainingTime: 2400 }
      },
      // Poisson Models
      {
        id: 'poisson-baseline',
        name: 'Poisson Gravity PINN',
        problemType: 'poisson-gravity',
        description: 'Standard PINN for solving Poisson equation with various density profiles.',
        isBaseline: true,
        trainedAt: new Date(Date.now() - 5 * 24 * 60 * 60 * 1000).toISOString(),
        metrics: { totalLoss: 4.1e-5, physicsLoss: 3.2e-5, dataLoss: 9e-6, epochs: 30000, trainingTime: 800 }
      },
      // Schrodinger Models
      {
        id: 'schrodinger-baseline',
        name: 'Quantum Well PINN',
        problemType: 'schrodinger-1d',
        description: 'PINN trained to find eigenstates of 1D quantum harmonic oscillator.',
        isBaseline: true,
        trainedAt: new Date(Date.now() - 10 * 24 * 60 * 60 * 1000).toISOString(),
        metrics: { totalLoss: 1.5e-5, physicsLoss: 1.1e-5, dataLoss: 4e-6, epochs: 40000, trainingTime: 1000 }
      },
      // Heat Models
      {
        id: 'heat-baseline',
        name: 'Heat Diffusion PINN',
        problemType: 'heat-diffusion',
        description: 'Baseline model for 1D heat equation with Dirichlet boundary conditions.',
        isBaseline: true,
        trainedAt: new Date(Date.now() - 2 * 24 * 60 * 60 * 1000).toISOString(),
        metrics: { totalLoss: 3.2e-5, physicsLoss: 2.5e-5, dataLoss: 7e-6, epochs: 25000, trainingTime: 600 }
      },
      {
        id: 'heat-adaptive',
        name: 'Adaptive Heat PINN',
        problemType: 'heat-diffusion',
        description: 'Advanced model with adaptive sampling for sharper temperature gradients.',
        isBaseline: false,
        trainedAt: new Date(Date.now() - 1 * 24 * 60 * 60 * 1000).toISOString(),
        metrics: { totalLoss: 9.8e-6, physicsLoss: 7.1e-6, dataLoss: 2.7e-6, epochs: 45000, trainingTime: 1100 }
      }
    ];

    if (problemType) {
      return allModels.filter(m => m.problemType === problemType);
    }
    return allModels;
  }

  getModelDetail(modelId: string): ModelDetail | null {
    const summary = this.getModels().find(m => m.id === modelId);
    if (!summary) return null;

    const problemConfig: Record<string, any> = {
      'lane-emden': {
        architecture: { type: 'MLP', layers: [1, 64, 64, 64, 1], activation: 'tanh', inputDim: 1, outputDim: 1 },
        problemParams: [
          { name: 'Polytropic Index', symbol: 'n', description: 'Equation of state parameter', min: 0, max: 5, default: 1.5, step: 0.1, trainedValue: 1.5 }
        ],
        inputDomain: { variables: [{ name: 'Radial Coordinate', symbol: 'ξ', min: 0, max: 10, description: 'Dimensionless radius' }] }
      },
      'poisson-gravity': {
        architecture: { type: 'MLP', layers: [1, 128, 128, 64, 1], activation: 'tanh', inputDim: 1, outputDim: 1 },
        problemParams: [
          { name: 'Central Density', symbol: 'ρ₀', description: 'Peak density', min: 0.1, max: 10, default: 1, step: 0.1, trainedValue: 1 },
          { name: 'Scale Length', symbol: 'a', description: 'Distribution size', min: 0.1, max: 5, default: 1, step: 0.1, trainedValue: 1 }
        ],
        inputDomain: { variables: [{ name: 'Position', symbol: 'x', min: -5, max: 5, description: 'Spatial coordinate' }] }
      },
      'schrodinger-1d': {
        architecture: { type: 'MLP', layers: [1, 64, 64, 64, 1], activation: 'tanh', inputDim: 1, outputDim: 1 },
        problemParams: [
          { name: 'Energy Level', symbol: 'E', description: 'Quantum energy', min: 0.1, max: 10, default: 1, step: 0.1, trainedValue: 0.5 },
          { name: 'Potential Depth', symbol: 'V₀', description: 'Well depth', min: 1, max: 20, default: 5, step: 0.5, trainedValue: 5 }
        ],
        inputDomain: { variables: [{ name: 'Position', symbol: 'x', min: -5, max: 5, description: 'Spatial coordinate' }] }
      },
      'heat-diffusion': {
        architecture: { type: 'MLP', layers: [2, 64, 64, 64, 1], activation: 'tanh', inputDim: 2, outputDim: 1 },
        problemParams: [
          { name: 'Thermal Diffusivity', symbol: 'α', description: 'Heat diffusion rate', min: 0.01, max: 1, default: 0.1, step: 0.01, trainedValue: 0.1 }
        ],
        inputDomain: { variables: [{ name: 'Position', symbol: 'x', min: 0, max: 1, description: 'Spatial coordinate' }] }
      }
    };

    const config = problemConfig[summary.problemType] || problemConfig['lane-emden'];

    return {
      ...summary,
      ...config,
      trainingConfig: { epochs: summary.metrics.epochs, learningRate: 0.001, optimizer: 'Adam', batchSize: 1024 }
    };
  }

  // ============================================
  // MOCK PREDICTION
  // ============================================
  generatePrediction(modelId: string, inputRange: { min: number; max: number; steps: number }, parameters: Record<string, number>): PredictionResult {
    const { min, max, steps } = inputRange;
    const x: number[] = [];
    const step = (max - min) / (steps - 1);
    for (let i = 0; i < steps; i++) {
      x.push(min + step * i);
    }

    // Generate physics-like output based on model type
    let y: number[];

    if (modelId.includes('lane-emden')) {
      const n = parameters['n'] || parameters['Polytropic Index'] || 1.5;
      // Lane-Emden-like solution (simplified)
      y = x.map(xi => {
        if (xi === 0) return 1;
        const theta = Math.max(0, 1 - (xi * xi) / (6 * (1 + n / 5)));
        return Math.pow(theta, n > 0 ? 1 : 1);
      });
    } else if (modelId.includes('poisson')) {
      // Gravitational potential-like
      const rho0 = parameters['ρ₀'] || parameters['Central Density'] || 1;
      const a = parameters['a'] || parameters['Scale Length'] || 1;
      y = x.map(xi => {
        const r = Math.abs(xi) + 0.1;
        return -rho0 * a * a / r * Math.exp(-r / a);
      });
    } else if (modelId.includes('schrodinger')) {
      // Wave function-like (Gaussian ground state)
      const E = parameters['E'] || parameters['Energy Level'] || 1;
      y = x.map(xi => {
        return Math.exp(-xi * xi / (2 * E)) * Math.cos(2 * Math.PI * xi / 5);
      });
    } else if (modelId.includes('heat')) {
      // Heat profile
      const alpha = parameters['α'] || parameters['Thermal Diffusivity'] || 0.1;
      y = x.map(xi => {
        return Math.sin(Math.PI * xi) * Math.exp(-alpha * Math.PI * Math.PI * 0.5);
      });
    } else {
      // Default: simple sine wave
      y = x.map(xi => Math.sin(xi));
    }

    return {
      inputs: { x },
      outputs: { y },
      computationTime: Math.floor(Math.random() * 50) + 10,
      modelId
    };
  }
}

